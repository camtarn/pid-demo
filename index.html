<!DOCTYPE HTML>
<html>
  <head>
    <title>
    PID controller tuning graphical demo
    </title>
    <style>
      html {
        height: 90%;
      }

      body {
        height: 100%;
        background: #334;
      }

      svg {
        filter: drop-shadow( -3px 3px 1px #445 );
      }

      path {
        stroke: #aaf;
      }

      circle {
        fill: #77f;
      }

      .setpoint {
        stroke: #4f4;
        fill: rgba( 128, 256, 128, 0.2 );
      }
    </style>
  </head>
  <body>
    <svg width="100%" height="100%">
    </svg>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
      var padding = 10; // percentage of height not to draw into, at top and bottom
      var setpointHeight = 100; // px
      var numPoints = 1000;
      var pointsPerSecond = 100;

      var processVar = 0;
      var controlVar = 0;

      var gravity = 0; /* 0.001; */ // constant acceleration added to velocity every frame
      var friction = 0.02; // 0-1: 0 = no friction, 1 = stops immediately if no force applied
      var mass = 500; // mass of 1 means a force of n will result in a velocity of n
      var velocity = 0;

      var previousError = 0;
      var integralAccumulator = 0;
      var proportionalGain = 1;
      var integralGain = 0;
      var derivativeGain = 0;
      var setpoint = 0;

      // Both of these only run for a single time step (they're run repeatedly
      // to produce multiple steps of data), so no need to take account of time
      // delta
      var controlFunction = function() {
        var error = setpoint - processVar;
        var proportional = error * proportionalGain;
        var integral = integralAccumulator = integralAccumulator + error
        var derivative = error - previousError;
        controlVar = proportional * proportionalGain + integral * integralGain + derivative * derivativeGain;
        controlVar = Math.max( -1, Math.min( 1, controlVar ) );
        previousError = error;
      };
      var plantFunction = function() {
        velocity *= 1 - friction;
        velocity = velocity + gravity + controlVar / mass;
        processVar += velocity;
        if( processVar >= 1 || processVar <= -1 ) {
          processVar = Math.max( -1, Math.min( 1, processVar ) );
          velocity = 0;
        }
      };

      var data = [];
      for( var i = 0; i < numPoints; i++ ) {
        data.push(0);
      }

      var width = d3.select('svg').node().clientWidth;
      var height = d3.select('svg').node().clientHeight;
      var xScale = d3.scaleLinear().domain([ 0, numPoints ]).range([ 0, width - 10 ]);
      var yScale = d3.scaleLinear().domain([ -1, 1 ]).range([ height * padding / 100, height * ( 1 - padding / 100 ) ]);

      var lineFunction = d3.line()
        .x( function( d, i ) { return xScale( i ); } )
        .y( function( d, i ) { return yScale( d ); } )
        .curve( d3.curveCardinal );

      d3.select( 'svg' )
        .append( 'path' )
          .attr( 'fill', 'none' )
          .attr( 'stroke-width', 2 )
          .attr( 'd', lineFunction( data ) );

      d3.select( 'svg' )
        .append( 'circle' )
          .attr( 'stroke', 'none' )
          .attr( 'r', 10 )
          .attr( 'cx', width - 10 );

      var setpointSliderDrag = d3.drag()
        .on( 'drag', function(d) {
          var value = yScale.invert( d3.event.y );
          setpoint = Math.min( 1, Math.max( -1, value ) );
          d3.select( '.setpoint' )
            .attr( 'y', yScale( setpoint ) - setpointHeight/2 );
        } );

      d3.select( 'svg' )
        .append( 'rect' )
          .classed( 'setpoint', true )
          .attr( 'strokeWidth', 2 )
          .attr( 'x', width - 100 )
          .attr( 'y', yScale( 0 ) - setpointHeight/2 )
          .attr( 'width', 100 )
          .attr( 'height', setpointHeight )
          .call( setpointSliderDrag );

      var frequency = 0.5; // Hz
      var previousElapsed = 0;
      var timer = d3.timer( function( elapsed ) {
        var elapsedSincePrev = elapsed - previousElapsed;
        var points = pointsPerSecond * elapsedSincePrev / 1000;
        if( points < 1 ) {
          return;
        }
        points = Math.floor( points );

        var newData = [];
        for( var i = 0; i < points; i++ ) {
          controlFunction();
          plantFunction();
          newData.push( processVar );
        }

        data = data.slice( points ).concat( newData );
        d3.select( 'path' ).attr( 'd', lineFunction( data ) );
        d3.select( 'circle' ).attr( 'cy', yScale( processVar ) );

        previousElapsed = elapsed;
      } );

    </script>
  </body>
</html>
